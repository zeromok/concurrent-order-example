# 동시성
## V0 (Single-thread)

### V0에서 보장하려는 것
- **성공한 주문(COMPLETED)만 재고가 감소**한다.
- 결제/재고/주문상태 변경은 **주문 1건 단위로 원자적(트랜잭션 1개)** 으로 처리된다.
- 주문 처리가 실패하면(예: 결제 실패/재고 부족) **메인 트랜잭션은 롤백**되어 재고/주문상태 변경이 남지 않는다.
- 실패 원인 추적을 위해 **실패 주문 기록은 별도 트랜잭션(REQUIRES_NEW)으로 커밋**되어 남는다.

### 왜 이렇게 나눴나
- `OrderProcessorV0`: 주문 1건 처리 유스케이스. `@Transactional` 경계를 담당한다.
- `FailedOrderRecorder`: 실패 주문 기록을 `REQUIRES_NEW`로 저장한다(부모 트랜잭션 롤백과 분리).
- `OrderServiceV0`: 여러 주문 순차 처리(orchestration) 및 조회용 API를 제공한다.
- Spring `@Transactional`은 **self-invocation(같은 클래스 내부 호출)** 에서는 적용되지 않으므로, 트랜잭션이 필요한 로직은 외부 빈으로 분리한다.

### V0에서 의도적으로 해결하지 않은 것
- 동시 주문 처리(멀티스레드)에서의 **레이스 컨디션/락/성능** 문제는 다루지 않는다.
- 결제 실패를 `Math.random()`으로 시뮬레이션하므로 테스트는 **비결정적(flaky 가능)** 이다.

### V1에서 바로 터지는 문제
- 멀티스레드로 동시에 주문을 처리하면 재고 차감이 **중복/누락**될 수 있다.
- 트랜잭션만으로는 해결되지 않는 동시성 이슈(가시성/동기화/락 경합)를 단계적으로 다룬다.

### V0
- V0는 결제 실패를 `Math.random()`으로 시뮬레이션하므로 테스트가 간헐적으로 흔들릴 수 있다.
- V1부터는 결제 성공/실패를 **주입 가능한 전략(예: `PaymentGateway` 인터페이스 + 테스트 더블)** 로 바꿔 테스트를 결정적으로 만든다.


V1: 멀티스레드 도입
V2: 스레드 생명주기 제어
V3: 메모리 가시성 문제 해결
V4: synchronized 동기화
V5: Lock 인터페이스
V6: BlockingQueue (생산자-소비자)
V7: Atomic 변수 (CAS)
V8: 동시성 컬렉션
V9: ExecutorService